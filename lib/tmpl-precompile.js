// Generated by CoffeeScript 1.4.0
(function() {
  var Namespacer, Precompiler, async, colors, extend, extractFunction, fs, globalSettings, jade, jsp, optimizeOutput, path, pro, util, version, _ref;

  version = [0, 1, 4];

  jade = require("../node_modules/jade");

  fs = require("fs");

  path = require("path");

  util = require("util");

  jsp = require("uglify-js").parser;

  pro = require("uglify-js").uglify;

  async = require("async");

  colors = require("./colors");

  Namespacer = require("./namespace");

  _ref = require("./optimize"), extractFunction = _ref.extractFunction, optimizeOutput = _ref.optimizeOutput;

  extend = require("./helpers").extend;

  globalSettings = {
    relative: true,
    dir: (function() {
      var d;
      if (module.parent.id === '.') {
        return process.cwd();
      } else {
        d = module.parent.id.split('/');
        return d.slice(0, d.length - 1).join('/');
      }
    })()
  };

  /*
  Precompiler(groupSettings)
  Description: Creates a Precompiler instance for executing precompiling work
  
  settings:
    "uglify": Boolean(default:false), whether to minify JS
    "namespace": String(Required), namespace object when including templates to browser
    "source": String(Required), relative path to source directory
    "output": String, relative path to output directory
    "templates": Array(Required), names of templates to be precompiled
    "compileDebug": Boolean(default: false), whether to compile Jade debugging
    "inline": Boolean(default: false), whether to inline Jade runtime functions
  
  function callback(err, res) {}
  (Optional) For Javascript API. If specified "res" will be the String of compiled templates
  of this group.
  
  Note: Either one or both of "callback"/"output" must be present, or there will be no output
  channel and the module will throw an error.
  */


  Precompiler = (function() {
    /*
      Binds settings, checks for dependencies and throw errors
    */

    function Precompiler(groupSettings, callback) {
      var self;
      this.settings = groupSettings;
      this.callback = callback;
      if (this.settings.source) {
        this.settings.source = path.normalize(globalSettings.dir + '/' + this.settings.source);
      } else {
        throw 'ERR: No source directory defined for ' + groupSettings.namespace;
      }
      if (this.settings.output) {
        this.settings.output = path.normalize(globalSettings.dir + '/' + this.settings.output);
      } else {
        if (this.callback == null) {
          throw 'ERR: No callback or output directory defined for ' + groupSettings.namespace;
        }
      }
      self = this;
      Namespacer(this.settings, function(err, res) {
        if (err != null) {
          throw err;
        } else {
          return self.namespaces = res.join('\n') + '\n';
        }
      });
    }

    /*
      compile()
      Description: Flow control and execution for the compilation
    */


    Precompiler.prototype.compile = function() {
      var buf, helpers, inline, namespaces, output, template, templates, uglify, _i, _len, _ref1, _ref2;
      _ref1 = this.settings, templates = _ref1.templates, namespaces = _ref1.namespaces, inline = _ref1.inline, helpers = _ref1.helpers, uglify = _ref1.uglify, output = _ref1.output;
      buf = [];
      buf.push("(function(){");
      if (namespaces !== false) {
        buf.push(this.namespaces);
      }
      if (helpers !== false && inline !== true) {
        buf.push(this.helpers());
      }
      _ref2 = this.settings.templates;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        template = _ref2[_i];
        buf.push(this.compileTemplate(template).toString());
      }
      buf.push("})();");
      buf = buf.join("");
      if (uglify !== false) {
        buf = this.uglifyOutput(buf);
      }
      if (output != null) {
        fs.writeFileSync(this.settings.output, buf);
        if (this.settings.verbose) {
          console.log(('Saving ' + (uglify !== false ? 'and Uglifying ' : '')).bold + ':' + output);
        }
      }
      if (this.callback != null) {
        return this.callback(null, buf);
      }
    };

    /*
      compileTemplate()
      Description: Compiles individual templates and returns them to compile()
    */


    Precompiler.prototype.compileTemplate = function(template) {
      var compileDebug, data, inline, namespace, source, sourceFile, templateNamespace, _ref1;
      _ref1 = this.settings, source = _ref1.source, namespace = _ref1.namespace, compileDebug = _ref1.compileDebug, inline = _ref1.inline;
      templateNamespace = template.replace(/\//g, '.');
      if (this.settings.verbose) {
        console.log("Compiling " + namespace + "." + templateNamespace + " from " + (source + template));
      }
      sourceFile = source + template + '.jade';
      data = fs.readFileSync(sourceFile, 'utf8');
      return namespace + '.' + templateNamespace + ' = ' + jade.compile(data, {
        compileDebug: compileDebug || false,
        filename: source,
        inline: inline || false
      }) + ';\n';
    };

    /*
      helpers()
      Description: Gets Jade's helpers and combines them into string
    */


    Precompiler.prototype.helpers = function() {
      var attrs, escape, obj, rethrow;
      attrs = jade.runtime.attrs.toString();
      escape = jade.runtime.escape.toString();
      rethrow = jade.runtime.rethrow.toString();
      if (this.settings.compileDebug) {
        obj = "var jade = {\n  attrs: attrs,\n  escape: escape,\n  rethrow: rethrow\n};\n";
        return [attrs, escape, rethrow, obj].join('\n');
      } else {
        obj = "var jade = {\n  attrs: attrs,\n  escape: escape\n};\n";
        return [attrs, escape, obj].join('\n');
      }
    };

    /*
      uglifyOutput(output)
      Description: Minifies generated JS with uglifyJS
    */


    Precompiler.prototype.uglifyOutput = function(output) {
      var ast;
      ast = jsp.parse(output);
      ast = pro.ast_mangle(ast);
      ast = pro.ast_squeeze(ast);
      return pro.gen_code(ast);
    };

    return Precompiler;

  })();

  /*
  ---Module exports---
  
  precompile(settings, dir)
  Description: Main precompile function
  
  Params:
    settings(object): Global settings object for tmpl-precompile
      "verbose": Boolean(default:false), if should output compile info on console
      "relative": Boolean(default:true), if paths to each template is relative to settings file
    dir(string): Main execution directory
    cb(function): callback to run when finished
  */


  module.exports.precompile = function(settings, dir, cb) {
    var _this = this;
    extend(globalSettings, settings);
    globalSettings.dir = dir;
    return async.forEach(settings.groups, function(groupSetting, callback) {
      var precompiler;
      precompiler = new Precompiler(groupSetting, callback);
      return precompiler.compile();
    }, function(err, res) {
      if (err != null) {
        return console.log(err);
      } else {
        if (cb != null) {
          return cb();
        }
        return console.log("\n\n\n...Done.\n\n");
      }
    });
  };

  module.exports.Precompiler = Precompiler;

}).call(this);
